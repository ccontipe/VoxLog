import logging
from tkinter import messagebox
import google.generativeai as genai # Importar diretamente

logger = logging.getLogger(__name__)

# Tenta importar google.generativeai globalmente, essencial para a GEM
try:
    import google.generativeai as genai
except ImportError:
    logger.critical("Erro Fatal: google.generativeai não pôde ser importado. A geração de solução AWS não funcionará. Verifique a instalação.")
    genai = None


def get_solution_prompt_aws(transcription_text):
    """
    Retorna o prompt completo para a geração de proposta de solução técnica para AWS,
    incluindo todas as diretrizes, exemplos de Terraform e instruções de output para a GEM.
    """
    # --------------------------------------------------------------------------
    # --- CONTEÚDO DA "GEM DE SOLUÇÃO" EMBUTIDO AQUI PARA AWS ---
    # Este prompt é específico para a plataforma AWS.
    # --------------------------------------------------------------------------
    main_solution_prompt_content = (
        "Você é uma inteligência artificial especializada em arquitetura de soluções em nuvem. Sua missão PRINCIPAL é analisar as informações fornecidas (que vêm de uma análise de transcrição de reuniões de negócios) e gerar uma proposta de solução técnica detalhada, **aderindo estritamente às diretrizes e padrões corporativos fornecidos, à plataforma cloud AWS e incluindo scripts Terraform para a infraestrutura**.\n\n"
        "**Sua resposta DEVE seguir rigorosamente a seguinte estrutura, com seções de texto, PlantUML e Terraform separadas por cabeçalhos específicos para facilitar a extração:**\n\n"
        "---\n\n"
        "### Proposta de Solução Técnica: Projeto [Nome do Projeto - inferir da transcrição] em AWS\n\n"
    )

    platform_specific_guidelines = (
        "**1. Análise do Problema e Requisitos:**\n\n"
        "   * Faça um resumo conciso do problema de negócio exposto na transcrição, incluindo os desafios principais (ex: prazo, complexidade de componentes, segurança, etc.).\n\n"
        "   * Liste os requisitos funcionais e não funcionais relevantes (ex: autenticação, autorização, exposição de serviços em API Gateway, integração com sistemas legados via arquivos ou chamadas à API, escalabilidade, segurança).\n\n"
        "   * Mencione explicitamente os modelos de autenticação, autorização, integração entre plataformas (cloud, on-premises, mainframe e open shift, etc.) e as preferências/preocupações levantadas.\n\n"
        "**2. Premissas de Negócio Essenciais:**\n\n"
        "   * Identifique e liste as principais premissas que a solução técnica deve respeitar (ex: faseamento da implementação, preferência por determinada forma de faturamento, restrições técnicas e orçamentárias se mencionadas, etc.).\n\n"
        "**3. Diretrizes e Premissas Corporativas para a Solução (AWS - CRUCIAL):**\n\n"
        "   * **Ambiente de Implantação:** Qualquer novo serviço computacional proposto deve ser criado e implementado exclusivamente no Ambiente AWS.\n"
        "   * **Componentes e Serviços:** As soluções devem utilizar preferencialmente os componentes e serviços nativos disponíveis na AWS.\n"
        "   * **Padrão Corporativo:** Evite o uso de serviços *serverless* excessivamente granulares (ex: AWS Lambda para lógicas de negócio complexas que seriam microsserviços inteiros). Priorize soluções baseadas em contêineres gerenciados como **Amazon ECS** (com Fargate) ou **Amazon EKS** para microsserviços. Não utilize soluções proprietárias de outros provedores.\n"
        "   * **Padrão de Artefato Corporativo:** Adapte os conceitos de rede e segurança para o ambiente AWS, utilizando VPCs, subnets, Security Groups, IAM, etc. Considere modelos como multi-account strategy, Landing Zone e Control Tower.\n\n"
        "**4. Visão Geral da Solução em AWS (Well-Architected Framework):**\n\n"
        "   * Descreva a abordagem geral da solução em AWS.\n\n"
        "   * Mencione a adesão aos pilares do AWS Well-Architected Framework (Excelência Operacional, Segurança, Confiabilidade, Eficiência de Performance, Otimização de Custos, Sustentabilidade).\n\n"
        "   * Identifique o padrão de arquitetura que mais se adapta ao problema identificado, preferencialmente utilizando **Microsserviços**.\n"
        "   * Explique como o padrão de arquitetura adotado (ex.: de microsserviços, Event-Driven Architecture, etc. ) é o modelo mais adequado para ser o pilar da solução.\n\n"
        "**5. Componentes da Solução AWS e sua Relação com o Problema/Solução:**\n\n"
        "   * Para cada componente AWS que você propor, siga este formato:\n\n"
        "       * **Nome do Componente AWS:** (Ex: Amazon EC2 / Amazon ECS / Amazon S3)\n\n"
        "       * **Relação com o Problema/Solução:** Explique como o componente atende a um requisito ou resolve parte do problema. Faça referência explícita aos \"10 componentes chave da arquitetura de microsserviços\" sempre que aplicável (ex: \"Servirá como plataforma para hospedar os **Microsserviços**\").\n\n"
        "       * **Well-Architected:** Descreva como o componente contribui para os pilares do Well-Architected Framework (ex: \"Promove a **Confiabilidade** através de alta disponibilidade...\"). **Para os microsserviços implantados no ECS/EKS, detalhe a contribuição individual de cada microsserviço para os pilares do Well-Architected Framework.**\n\n"
        "   * Detalhe os serviços AWS propostos e sua relação com a solução, bem como sua contribuição para os pilares do Well-Architected Framework.\n\n"
        "   * Certifique-se de abordar componentes que cobrem os requisitos de:\n\n"
        "       * Hospedagem de aplicações (microsserviços, portal administrativo interno, portal de consumo externo para parceiros, etc.).\n\n"
        "       * Gerenciamento de APIs (API Gateway).\n\n"
        "       * Bancos de dados (RDS, DynamoDB, DocumentDB).\n\n"
        "       * Comunicação síncrona/assíncrona (SQS, SNS, EventBridge).\n\n"
        "       * Gerenciamento de identidades (IAM, Cognito).\n\n"
        "       * Monitoramento (CloudWatch, X-Ray).\n\n"
        "       * Balanceamento de carga e CDN (ELB, CloudFront).\n\n"
        "       * Conectividade híbrida (Direct Connect, VPN).\n\n"
        "       * Segurança de segredos (Secrets Manager).\n\n"
        "**6. Segurança e Conformidade (PCI SSC):**\n\n"
        "   * Com base na necessidade de lidar com dados sensíveis, especialmente dados de cartão (se aplicável), detalhe como a solução proposta atende ou se alinha aos padrões do PCI Security Standards Council (PCI SSC), conforme lembrado: \"O PCI Security Standards Council (PCI SSC) estabelece padrões de segurança para proteger dados de cartão, desde o design de software até o manuseio de dispositivos físicos. Os principais padrões incluem PCI DSS, PCI P2PE, Secure Software Standard & Secure SLC, e PTS POI. O PCI SSC oferece recursos suplementares e programas de qualificação para profissionais. A conformidade com os padrões PCI é crucial para organizações que lidam com dados de cartões.\"\n"
        "   * Explique como os componentes AWS escolhidos contribuem para a conformidade com o PCI DSS (Data Security Standard) e outros padrões relevantes do PCI SSC, incluindo aspectos como:\n"
        "       * Proteção de Dados de Titular de Cartão: Como os dados sensíveis são armazenados e transmitidos de forma segura.\n"
        "       * Segurança de Redes e Sistemas: Medidas para proteger a rede e os sistemas de acessos não autorizados.\n"
        "       * Controle de Acesso: Como o acesso aos dados é restrito e monitorado.\n"
        "       * Monitoramento e Testes Regulares: Como a segurança será continuamente monitorada e testada.\n"
        "       * Manutenção de uma Política de Segurança da Informação: A importância da documentação e conscientização sobre as políticas de segurança.\n\n"
    )
    plantuml_section_guidelines = (
        "**9. Geração de Diagramas PlantUML (AWS):**\n\n"
        "Gere o código PlantUML para os seguintes diagramas. Assegure-se de que os nomes dos elementos sejam consistentemente com a descrição da solução e reflitam os serviços AWS.\n\n"
        "**Formato de Saída para PlantUML:**\n"
        "Para cada diagrama, envolva o código PlantUML em blocos de código Markdown ````plantuml` e use cabeçalhos específicos:\n\n"
        "#### Diagrama PlantUML: C1 Contexto\n"
        "```plantuml\n"
        "@startuml <NomeDoDiagrama>\n\n"
        "!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Context.puml\n"
        "LAYOUT_WITH_LEGEND()\n\n"
        "title Diagrama de Contexto do Sistema: [Nome do Projeto]\n\n"
        "Person(user, \"Usuário\", \"Utiliza a aplicação\")\n"
        "System(System, \"[Nome do Sistema]\", \"Sistema principal em AWS\")\n"
        "System_Ext(LegacySystem, \"Sistema Legado\", \"Sistema de [descrever] (On-premises)\")\n\n"
        "Rel(user, System, \"Utiliza\", \"HTTPS\")\n"
        "Rel(System, LegacySystem, \"Integra com\", \"API REST / FTP\")\n"
        "@enduml\n"
        "```\n\n"
        "#### Diagrama PlantUML: C2 Contêineres\n"
        "```plantuml\n"
        "@startuml <NomeDoDiagrama>\n\n"
        "!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml\n"
        "LAYOUT_WITH_LEGEND()\n\n"
        "title Diagrama de Contêineres: [Nome do Projeto]\n\n"
        "System_Boundary(c4_System, \"[Nome do Sistema]\") {\n"
        "  Container(spa, \"Portal Web\", \"JavaScript e React\", \"Permite acesso via navegador\")\n"
        "  Container(api_gateway, \"API Gateway\", \"AWS API Gateway\", \"Expõe APIs para microsserviços\")\n"
        "  Container(microsservicos_eks, \"Microsservicos Core\", \"Containers no Amazon EKS / ECS Fargate\", \"Serviços de negócio central\")\n"
        "  ContainerDb(database, \"Banco de Dados Principal\", \"Amazon RDS PostgreSQL\", \"Armazena dados transacionais\")\n"
        "  Container(message_broker, \"Message Broker\", \"Amazon SQS / SNS\", \"Comunicação assíncrona\")\n"
        "}\n\n"
        "Person(user, \"Usuário\")\n"
        "System_Ext(LegacySystem, \"Sistema Legado\")\n\n"
        "Rel(user, spa, \"Acessa\", \"HTTPS\")\n"
        "Rel(spa, api_gateway, \"Faz chamadas API\", \"HTTPS\")\n"
        "Rel(api_gateway, microsservicos_eks, \"Encaminha requisições para\", \"HTTPS\")\n"
        "Rel(microsservicos_eks, database, \"Lê e Escreve\", \"SQL\")\n"
        "Rel(microsservicos_eks, message_broker, \"Envia/Recebe mensagens de\", \"SQS/SNS\")\n"
        "Rel(microsservicos_eks, LegacySystem, \"Integra via\", \"API REST / SFTP\")\n"
        "@enduml\n"
        "```\n\n"
        "#### Diagrama PlantUML: C3 Componentes\n"
        "```plantuml\n"
        "@startuml <NomeDoDiagrama>\n\n"
        "!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml\n"
        "LAYOUT_WITH_LEGEND()\n\n"
        "title Diagrama de Componentes: Microsserviços Core (AWS)\n\n"
        "Container_Boundary(microsservicos_eks, \"Microsserviços Core (EKS/ECS)\") {\n"
        "  Component(comp_users, \"Serviço de Usuários\", \"Spring Boot REST API\", \"Gerencia perfis de usuários\")\n"
        "  Component(comp_products, \"Serviço de Produtos\", \"Node.js REST API\", \"Gerencia catálogo de produtos\")\n"
        "  Component(comp_orders, \"Serviço de Pedidos\", \"Python Flask REST API\", \"Processa pedidos e transações\")\n"
        "  Component(comp_notifications, \"Serviço de Notificações\", \"Java REST API\", \"Envia notificações (email, sms)\")\n"
        "}\n\n"
        "ContainerDb(database, \"Banco de Dados Principal\")\n"
        "Container(message_broker, \"Message Broker\")\n\n"
        "Rel(comp_users, database, \"Lê e Escreve\", \"SQL\")\n"
        "Rel(comp_products, database, \"Lê e Escreve\", \"SQL\")\n"
        "Rel(comp_orders, database, \"Lê e Escreve\", \"SQL\")\n"
        "Rel(comp_orders, comp_notifications, \"Envia pedido para\", \"Mensagem Assíncrona\")\n"
        "Rel(comp_notifications, message_broker, \"Publica/Consome de\", \"SQS/SNS\")\n"
        "@enduml\n"
        "```\n\n"
        "#### Diagrama PlantUML: Sequência\n"
        "```plantuml\n"
        "@startuml <NomeDoDiagrama>\n\n"
        "title Fluxo de Processamento de Pedido\n\n"
        "participant \"Cliente (Portal Web)\" as Cliente\n"
        "participant \"API Gateway (AWS APIGW)\" as APIGateway\n"
        "participant \"Microsserviço de Pedidos (EKS)\" as OrderService\n"
        "participant \"Banco de Dados Principal (RDS)\" as Database\n"
        "participant \"Message Broker (SQS/SNS)\" as MessageBroker\n"
        "participant \"Microsserviço de Notificações (EKS)\" as NotificationService\n\n"
        "Cliente -> APIGateway: Requisição de Pedido (HTTPS)\n"
        "APIGateway -> OrderService: Encaminha Pedido (HTTPS)\n"
        "OrderService -> Database: Salva Detalhes do Pedido (SQL)\n"
        "Database --> OrderService: Confirmação\n"
        "OrderService -> MessageBroker: Publica Evento 'Pedido Processado' (SQS)\n"
        "MessageBroker -> NotificationService: Envia Evento\n"
        "NotificationService -> Cliente: Envia Confirmação de Pedido (Email/SMS)\n"
        "@enduml\n"
        "```\n\n"
    )
    terraform_templates_str = ( # Convertido para string única para ser inserido no prompt
        "**10. Geração de Scripts Terraform (AWS):**\n\n"
        "Gere os blocos de código Terraform para provisionar os recursos AWS propostos, seguindo a estrutura de arquivos e as diretrizes de nomenclatura.\n"
        "Priorize o uso de módulos Terraform (ex: `vpc`, `eks`, `rds`) para reutilização.\n\n"
        "**Formato de Saída para Terraform:**\n"
        "Para cada arquivo Terraform, envolva o código em blocos de código Markdown ````terraform` e use cabeçalhos específicos:\n\n"
        "#### Arquivo Terraform: versions.tf\n"
        "```terraform\n"
        "terraform {\n"
        "  required_providers {\n"
        "    aws = {\n"
        "      source  = \"hashicorp/aws\"\n"
        "      version = \"~> 5.0\"\n"
        "    }\n"
        "  }\n"
        "  required_version = \">= 1.0.0\"\n"
        "}\n"
        "```\n\n"
        "#### Arquivo Terraform: providers.tf\n"
        "```terraform\n"
        "provider \"aws\" {\n"
        "  region = var.region\n"
        "  # Credenciais configuradas via AWS CLI, IAM Roles, etc.\n"
        "}\n\n"
        "# Configuração do backend para estado remoto (ex: S3)\n"
        "# terraform {\n"
        "#   backend \"s3\" {\n"
        "#     bucket = \"my-terraform-state-bucket\"\n"
        "#     key    = \"path/to/my/terraform.tfstate\"\n"
        "#     region = \"us-east-1\"\n"
        "#     dynamodb_table = \"my-terraform-locks\"\n"
        "#   }\n"
        "# }\n"
        "```\n\n"
        "#### Arquivo Terraform: variables.tf\n"
        "```terraform\n"
        "variable \"project_name\" {\n"
        "  description = \"Nome do projeto/aplicação.\"\n"
        "  type        = string\n"
        "}\n\n"
        "variable \"environment\" {\n"
        "  description = \"Ambiente de implantação (ex: dev, prd, hml).\"\n"
        "  type        = string\n"
        "}\n\n"
        "variable \"region\" {\n"
        "  description = \"Região AWS para os recursos.\"\n"
        "  type        = string\n"
        "  default     = \"us-east-1\"\n"
        "}\n\n"
        "variable \"vpc_cidr_block\" {\n"
        "  description = \"CIDR block para a VPC.\"\n"
        "  type        = string\n"
        "  default     = \"10.0.0.0/16\"\n"
        "}\n\n"
        "variable \"private_subnet_cidrs\" {\n"
        "  description = \"Lista de CIDR blocks para as subnets privadas.\"\n"
        "  type        = list(string)\n"
        "  default     = [\"10.0.1.0/24\", \"10.0.2.0/24\"]\n"
        "}\n\n"
        "variable \"public_subnet_cidrs\" {\n"
        "  description = \"Lista de CIDR blocks para as subnets públicas.\"\n"
        "  type        = list(string)\n"
        "  default     = [\"10.0.101.0/24\", \"10.0.102.0/24\"]\n"
        "}\n\n"
        "variable \"eks_cluster_name_prefix\" {\n"
        "  description = \"Prefixo para o nome do cluster EKS.\"\n"
        "  type        = string\n"
        "  default     = \"eks-cluster\"\n"
        "}\n\n"
        "variable \"db_master_username\" {\n"
        "  description = \"Nome de usuário para o banco de dados (referenciado de Secrets Manager).\"\n"
        "  type        = string\n"
        "  default = \"dbuser\"\n"
        "}\n\n"
        "# Exemplo de variável para referência a segredos via Secrets Manager\n"
        "variable \"db_master_password_secret_name\" {\n"
        "  description = \"Nome do segredo no Secrets Manager para a senha do DB.\"\n"
        "  type        = string\n"
        "}\n"
        "```\n\n"
        "#### Arquivo Terraform: main.tf\n"
        "```terraform\n"
        "# Exemplo de Módulo de VPC (modules/vpc)\n"
        "module \"vpc\" {\n"
        "  source = \"./modules/vpc\"\n"
        "  name = \"${var.project_name}-${var.environment}-vpc\"\n"
        "  cidr = var.vpc_cidr_block\n"
        "  azs = [\"${var.region}a\", \"${var.region}b\"]\n"
        "  private_subnets = var.private_subnet_cidrs\n"
        "  public_subnets = var.public_subnet_cidrs\n"
        "  enable_nat_gateway = true\n"
        "  single_nat_gateway = true\n"
        "  tags = {\n"
        "    Environment = var.environment\n"
        "    Project     = var.project_name\n"
        "  }\n"
        "}\n\n"
        "# Exemplo de Secrets Manager para senhas de DB\n"
        "resource \"aws_secretsmanager_secret\" \"db_password\" {\n"
        "  name        = var.db_master_password_secret_name\n"
        "  description = \"Senha do usuário mestre do banco de dados para ${var.project_name}\"\n"
        "}\n\n"
        "resource \"aws_secretsmanager_secret_version\" \"db_password_version\" {\n"
        "  secret_id     = aws_secretsmanager_secret.db_password.id\n"
        "  secret_string = \"SenhaGeradaOuBuscadaDeAlgumLugarSeguro\" # Em um cenário real, não seria hardcoded\n"
        "}\n\n"
        "# Exemplo de Amazon EKS Cluster\n"
        "# Requer VPC e roles IAM pré-configurados.\n"
        "resource \"aws_eks_cluster\" \"main\" {\n"
        "  name     = \"${var.eks_cluster_name_prefix}-${var.project_name}-${var.environment}\"\n"
        "  role_arn = \"arn:aws:iam::123456789012:role/eks-cluster-role\" # Substituir pelo ARN real\n"
        "  vpc_config {\n"
        "    subnet_ids = concat(module.vpc.private_subnets, module.vpc.public_subnets)\n"
        "  }\n"
        "  version = \"1.28\"\n"
        "  tags = {\n"
        "    Environment = var.environment\n"
        "    Project     = var.project_name\n"
        "  }\n"
        "}\n\n"
        "resource \"aws_db_instance\" \"db_core\" {\n"
        "  identifier            = \"${var.project_name}-db-${var.environment}\"\n"
        "  engine                = \"postgres\"\n"
        "  engine_version        = \"13.5\"\n"
        "  instance_class        = \"db.t3.micro\"\n"
        "  allocated_storage     = 20\n"
        "  db_subnet_group_name  = module.vpc.database_subnet_group\n"
        "  vpc_security_group_ids = [module.vpc.default_security_group_id] # Exemplo, idealmente SG dedicado\n"
        "  name                  = \"${var.project_name}_db\"\n"
        "  username              = var.db_master_username\n"
        "  password              = aws_secretsmanager_secret_version.db_password_version.secret_string # Referência ao segredo\n"
        "  skip_final_snapshot   = true\n"
        "  tags = {\n"
        "    Environment = var.environment\n"
        "    Project     = var.project_name\n"
        "  }\n"
        "}\n\n"
        "resource \"aws_api_gateway_rest_api\" \"api_gateway\" {\n"
        "  name        = \"${var.project_name}-api-${var.environment}\"\n"
        "  description = \"API Gateway para microsserviços de ${var.project_name}\"\n"
        "  tags = {\n"
        "    Environment = var.environment\n"
        "    Project     = var.project_name\n"
        "  }\n"
        "}\n"
        "```\n\n"
        "#### Arquivo Terraform: outputs.tf\n"
        "```terraform\n"
        "output \"vpc_id\" {\n"
        "  description = \"ID da VPC criada.\"\n"
        "  value       = module.vpc.vpc_id\n"
        "}\n\n"
        "output \"eks_cluster_endpoint\" {\n"
        "  description = \"Endpoint do cluster EKS.\"\n"
        "  value       = aws_eks_cluster.main.endpoint\n"
        "}\n\n"
        "output \"api_gateway_url\" {\n"
        "  description = \"URL base do API Gateway.\"\n"
        "  value       = aws_api_gateway_rest_api.api_gateway.url\n"
        "}\n"
        "```\n"
    )

    # Concatena o prompt base com as diretrizes específicas da plataforma e a seção Terraform
    full_prompt = (
        main_solution_prompt_content +
        platform_specific_guidelines +
        "**7. Informações Relevantes Adicionais:**\n\n" # Seção para informações como os 10 componentes de microsserviços
        "   * **UTILIZE AS SEGUINTES INFORMAÇÕES SALVAS:**\n\n"
        "       * \"Visão geral dos 10 componentes chave da arquitetura de microsserviços: Cliente, CDN, Load Balancer, API Gateway, Microsserviços, Message Broker, Databases, Identity Provider, Service Registry e Discovery, Service Coordenação (e.g., Zookeeper).\"\n\n"
        + plantuml_section_guidelines +
        terraform_templates_str + # Adiciona a string com todos os templates Terraform
        f"Transcrição analisada:\n{transcription_text}"
    )
    
    return full_prompt

def call_gemini_api_aws(prompt_text, prompt_purpose, api_key):
    """
    Chama o modelo Gemini com o texto do prompt fornecido, específico para AWS.
    """
    logger.info(f"[Módulo Solução AWS] Chamando o modelo Gemini para: {prompt_purpose}.")
    if genai is None:
        messagebox.showerror("Erro de Dependência", "A biblioteca 'google.generativeai' não está disponível. Não é possível gerar a solução AWS.")
        logger.error("google.generativeai não carregado. Geração de solução AWS abortada.")
        return None

    genai.configure(api_key=api_key)

    try:
        model = genai.GenerativeModel('models/gemini-1.5-flash')
        logger.debug(f"[Módulo Solução AWS] Prompt enviado para Gemini (primeiros 200 chars): {prompt_text[:200]}...")
        
        response = model.generate_content(prompt_text)
        logger.info(f"[Módulo Solução AWS] Resposta da GEM para {prompt_purpose} recebida com sucesso.")
        return response.text
    except Exception as e:
        logger.error(f"[Módulo Solução AWS] Erro ao chamar a API da GEM para {prompt_purpose}: {e}", exc_info=True)
        messagebox.showerror(f"Erro na GEM de Solução AWS", f"Não foi possível obter a resposta da GEM: {e}")
        return None